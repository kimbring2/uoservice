<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="">
    <meta name="author" content="">
    <link rel="icon" href="../../../../favicon.ico">

    <title>UoService</title>

    <!-- Bootstrap core CSS -->
    <link href="https://getbootstrap.com/docs/4.1/dist/css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom styles for this template -->
    <link href="css/tmp.css" rel="stylesheet">

    <script src="js/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </head>

  <body>
    <nav class="navbar navbar-expand-md navbar-dark bg-dark fixed-top">
      <a class="navbar-brand" href="https://github.com/kimbring2/uoservice">GitHub</a>
      <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarsExampleDefault" aria-controls="navbarsExampleDefault" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
      </button>

      <div class="collapse navbar-collapse" id="navbarsExampleDefault">
        <ul class="navbar-nav mr-auto">
            <li class="nav-item">
              <a class="nav-link" href="index.html">Home<span class="sr-only">(current)</span></a>
            </li>

            <li class="nav-item active">
              <a class="nav-link" href="states_actions.html">States/Actions<span class="sr-only"></span></a>
            </li>

            <li class="nav-item active">
              <a class="nav-link" href="tutorial_basic.html">Basic Tutorial<span class="sr-only"></span></a>
            </li>

            <li class="nav-item active">
              <a class="nav-link" href="tutorial_replay.html">Replay Tutorial<span class="sr-only"></span></a>
            </li>
        </ul>
      </div>
    </nav>
    
<main role="main" class="container-fluid">
    <div class="starter-template">
        <h1>Basic tutorial</h1>
    </div>
    <div class="container-fluid">
        <div class="row">
            <div class="col">
                <h5>Figure1: Synchronization diagram between python script and the environment.</h5>
                <img src="Fig/Process.png" class="rounded mx-auto d-block float-center" alt="Training process" width=100%>
            </div>
            <div class="col">
                <h2>Synchronization in Python</h2>
                Figure 1 shows the pattern of interaction between Python and Ultima Online client(C#) processes. First, python script 
                samples an action from the model, meanwhile the C# process waits for the action to be passed. In this 
                case <b>ActSemaphore</b> is blocked, while <b>ObsSemaphore</b> has green light. <br>
                When the <b>step</b> function is called the action tensor is sent into the shared memory and <b>ActSemaphore</b>
                turns green. It signals to C# to start processing the action of an agent. Meanwhile the <b>ObsSemaphore</b> turns
                red, blocking python process while waiting for C# to send the observation.<br>
            </div>
            <div class="col">
                <h5><a href="https://github.com/kimbring2/uoservice/blob/main/uoservice/UoService.py">Code 1: Introducing semaphores</a></h5>
                <pre class="pre"><code class="python">
class UoService:
    '''UoService class including gRPC client'''
    def __init__(self, grpc_port, window_width, window_height):
            self.grpc_port = grpc_port
            self.window_width = window_width
            self.window_height = window_height
            self.stub = None

    def _open_grpc(self):
        # Open the gRPC channel using the port that is same of game client 
        channel = grpc.insecure_channel('localhost:' + str(self.grpc_port))
        self.stub = UoService_pb2_grpc.UoServiceStub(channel)

    def step(self, action):
        # Send the action data to game client and receive the state of that action
        action_type = action['action_type']
        item_serial = action['item_serial']
        mobile_serial = action['mobile_serial']
        walk_direction = action['walk_direction']
        index = action['index']
        amount = action['amount']
        run = action['run']

        self.stub.WriteAct(UoService_pb2.GrpcAction(actionType=action_type, 
                                                    itemSerial=item_serial,
                                                    mobileSerial=mobile_serial,
                                                    walkDirection=walk_direction,
                                                    index=index, 
                                                    amount=amount,
                                                    run=run))
        self.stub.ActSemaphoreControl(UoService_pb2.SemaphoreAction(mode='post'))

        self.stub.ObsSemaphoreControl(UoService_pb2.SemaphoreAction(mode='wait'))
        response = self.stub.ReadObs(UoService_pb2.Config(name='step'))
                </code></pre>
            </div>
        </div>

        <div class="row">
            <div class="col">
            </div>
            <div class="col">
                <h2>First Walk</h2>
                The most basic action in an MMORPG game would be walking close to a specific monster. Let's see how to use the states and actions of the UoService to do that through Python code.<br> 

                The pre-work before interacting with game client is to declare the UoService class seen above, connect gRPC communication, and call the reset() function. 

                First infomation we need to know might be position of player. That can be obtained from the <b>player_game_x, player_game_y</b> of the <b>uo_service</b>. Next, we need to know information of monsters around the player, which is included in <b>world_mobile_dict</b>. There can be various types and multiple numbers of mobiles in the same space as the player. Here, only one mobile named <b>Skeleton</b> near the player is selected using the <b>name</b> and <b>distance</b> value of mobile state.

                How can we make up the arguments <b>actionType, itemSerial, mobileSerial, walkDirection, index, amount, run</b> of action for walk. First, we just know that the actionType should be 1. Next, the value for the walkDirection can be calculated from the x and y position of player and monster by using the <a href="https://github.com/kimbring2/uoservice/blob/main/uoservice/utils.py">simple planning algorithm</a>. If you need to approach quickly to monster, set the run arguemnt of action as True. 

                <video width="400" height="200" controls>
                    <source src="Fig/WalkResult.mkv" type="video/mp4">
                    Your browser does not support the video tag.
                </video>
            </div>

            <div class="col">
                <h5><a href="https://github.com/kimbring2/uoservice/blob/main/uoservice/examples/walk_to_monster.py">Code 2: Rule-based walking example code</a></h5>
                <pre class="pre"><code class="python">
uo_service = UoService(grpc_port, window_width, window_height)
uo_service._open_grpc()
obs = uo_service.reset()

target_serial = None

for step in range(100000):
    player_game_x = uo_service.player_game_x
    player_game_y = uo_service.player_game_y

    if len(uo_service.world_mobile_dict) != 0 and target_serial == None:
      serial_list = [k for k, v in uo_service.world_mobile_dict.items() \
                     v['name'] == ' A Skeleton ' and v['distance'] <= 15 \
                     and v['distance'] > 5]

      target_serial = random.choice(serial_list)

    action = {}
    action['action_type'] = 0
    action['item_serial'] = 0
    action['mobile_serial'] = 0
    action['walk_direction'] = 0
    action['index'] = 0
    action['amount'] = 0
    action['run'] = False

    if step % 50 == 0:
      if target_serial != None and player_game_x != None:
        if target_serial in uo_service.world_mobile_dict:
          target_skeleton = uo_service.world_mobile_dict[target_serial]

        target_game_x = target_skeleton["gameX"]
        target_game_y = target_skeleton["gameY"]

        direction = utils.get_walk_direction_to_target([player_game_x, player_game_y], 
                                                       [target_game_x, target_game_y])

        if direction != -1:
          action['action_type'] = 1
          action['walk_direction'] = direction
          action['run'] = True

    uo_service.step(action)
                </code></pre>
            </div>
        </div>
        
        <div class="row">
            <div class="col">
            </div>
            <div class="col">
                <h2>First Attack</h2>
                After getting close to a monster, the most basic interaction possible would be an attack. Let's use the more state and action of the UoService to do that. <br> 
                Melee attacks are possible only when the distance from the monster is almost zero. Therefore, this distance should be checked before attacking. This information is contained in the mobile's <b>distance</b> part, and you can acquire a value through the <b>target_mobile['distance']</b> code.<br> 
                
                Next, the player must be in the war mode to attack enemie in Ultima Online. You must check the current status of mode by using the <b>war_mode</b> value of UoService class like a <b>uo_service.war_mode</b> If it is false, set the <b>action_type</b> and <b>index</b> argument of action to 19 and 1 respectively to set the player as war mode. <br> 

                Finally, if the player approach close to the monster and war mode is true, you can set the <b>action_type</b> as 2. Additionally, the <b>mobile_serial</b> argument is needed to be set as the serial of target mobile.

                <video width="400" height="200" controls>
                    <source src="Fig/MeleeAttackResult.mkv" type="video/mp4">
                    Your browser does not support the video tag.
                </video>
            </div>

            <div class="col">
                <h5><a href="https://github.com/kimbring2/uoservice/blob/main/uoservice/examples/walk_to_monster.py">Code 3: Rule-based attacking example code</a>.</h5>
                <pre class="pre"><code class="python">
uo_service = UoService(grpc_port, window_width, window_height)
uo_service._open_grpc()
obs = uo_service.reset()

target_serial = None
for step in range(100000):
    player_game_x = uo_service.player_game_x
    player_game_y = uo_service.player_game_y
    if len(uo_service.world_mobile_dict) != 0 and target_serial == None:
      serial_list = [k for k, v in uo_service.world_mobile_dict.items() \
                     v['name'] == ' A Skeleton ' and v['distance'] <= 15 \
                     and v['distance'] > 5]
      target_serial = random.choice(serial_list)

    action = {}
    action['action_type'] = 0
    action['item_serial'] = 0
    action['mobile_serial'] = 0
    action['walk_direction'] = 0
    action['index'] = 0
    action['amount'] = 0
    action['run'] = False
    if step % 50 == 0:
      if target_serial != None and player_game_x != None:
        if target_serial in uo_service.world_mobile_dict:
          target_mobile = uo_service.world_mobile_dict[target_serial]

        target_game_x = target_mobile["gameX"]
        target_game_y = target_mobile["gameY"]

        direction = utils.get_walk_direction_to_target([player_game_x, player_game_y], 
                                                       [target_game_x, target_game_y])
        distance = target_mobile['distance']
        war_mode = uo_service.war_mode

        if distance >= 2:
          if direction == -1:
            action['action_type'] = 0
          else:
            ## Walk toward target mobile
            action['action_type'] = 1
            action['walk_direction'] = direction
            action['run'] = True
        else:
            if war_mode == False:
              action['action_type'] = 19
              action['index'] = 1
            else:
              action['action_type'] = 2
              action['mobile_serial'] = target_serial
        
        obs = uo_service.step(action)
                </code></pre>
            </div>

        </div>

        <div class="row">
            <div class="col">
            </div>
            <div class="col">
                <h2>First corpse looting</h2>
                After attacking and killing a monster, player can acquire various items including gold from the corpse. To do this with python code, first you need to check <b>world_item_dict</b> of the <b>uo_service</b> instead of the <b>world_mobile_dict</b> because the monster that was mobile type is transformed to an item when it dies. For the reason that the corresponding Dict has information on all items of the world, you should filter it using the <b>isCorpse</b> value.<br>

                Having secured the serial number of the corpse that exists around the player, the next step is to open it. The corresponding action can be composed by setting the <b>action_type</b> as 7 and <b>item_serial</b> as the serial number of the corpse item.<br>

                From the moment the corpse is opened, world_item_dict start to include the items of that corpse. To determine which item is inside the corpse, the <b>container</b> part of item information can be used <b>item["container"]</b>. If you want to select only gold among the identified items inside the corpse, you can use the <b>name</b> information of item like a <b>if "gold" in item["name"]</b>.<br>

                Having obtained a serial of the gold item of opened corpse, that item should be picked up before putting it in the player backpack. This can be done by setting the <b>action_type</b> as 3, <b>item_serial</b> to the serial of the gold item, and <b>amount</b> to the total number of gold.<br>

                When picking up an item, <b>hold_item_serial</b> of <b>uo_service</b> is changed to the serial number of the item. Finally, player can drop the currently held item onto the backpack by setting <b>action_type</b> to 4 causes the.<br>

                In order to check whether the player looted gold well, you can check the <b>gold part</b> of <b>player_status_dictt</b> of uo_service like <b>player_status_dict['gold']</b>.

                <video width="400" height="200" controls>
                    <source src="Fig/LootingCorpseResult.mkv" type="video/mp4">
                    Your browser does not support the video tag.
                </video>
            </div>
            <div class="col">
                <h5><a href="https://github.com/kimbring2/uoservice/blob/main/uoservice/examples/looting_the_corpse.py">Code 4: Rule-based looting the corpse example code</a>.</h5>
                <pre class="pre"><code class="python">
  target_mobile_serial = None
  corpse_dict = {}
  corpse_serial = None
  hold_item_serial = 0
  corpse_item_dict = {}

  for step in range(100000):
    player_game_x = uo_service.player_game_x
    player_game_y = uo_service.player_game_y

    if len(uo_service.world_mobile_dict) != 0 and target_mobile_serial == None:
      skeleton_serial_list = [k for k, v in uo_service.world_mobile_dict.items() \
               if v['name'] == ' A Skeleton ' and v['distance'] <= 15 and v['distance'] > 5]
      target_mobile_serial = random.choice(skeleton_serial_list)

    corpse_dict = {}
    for k, v in uo_service.world_item_dict.items():
      if v["isCorpse"] == True:
        corpse_dict[k] = v

    action = {}
    action['action_type'] = 0
    action['item_serial'] = 0
    action['mobile_serial'] = 0
    action['walk_direction'] = 0
    action['index'] = 0
    action['amount'] = 0
    action['run'] = False
    if step % 150 == 0:
      if len(uo_service.player_status_dict) != 0:
        player_gold = uo_service.player_status_dict['gold']

      if target_mobile_serial != None and player_game_x != None:
        if target_mobile_serial in uo_service.world_mobile_dict:
          target_mobile = uo_service.world_mobile_dict[target_skeleton_serial]
        else:
          target_mobile_serial = None
          continue

        target_mobile_game_x = target_mobile["gameX"]
        target_mobile_game_y = target_mobile["gameY"]

        direction = utils.get_walk_direction_to_target([player_game_x, player_game_y], 
                                         [target_mobile_game_x, target_mobile_game_y])
        distance = target_mobile['distance']
        war_mode = uo_service.war_mode
        hold_item_serial = uo_service.hold_item_serial

        for k_corpse, v_corpse in corpse_dict.items():
          for k_world, v_world in uo_service.world_item_dict.items():
            if k_corpse == v_world["container"]:
              if k_world not in corpse_item_dict:
                corpse_item_dict[k_world] = uo_service.world_item_dict[k_world]
              else:
                corpse_item_dict[k_world] = uo_service.world_item_dict[k_world]

        if len(corpse_dict) == 0:
          if distance >= 2:
            if direction == -1:
              action['action_type'] = 0
            else:
              action['action_type'] = 1
              action['walk_direction'] = direction
              action['run'] = True
          else:
              if war_mode == False:
                action['action_type'] = 19
                action['index'] = 1
              else:
                action['action_type'] = 2
                action['mobile_serial'] = target_mobile_serial
        else:
          if len(corpse_item_dict) == 0:
            corpse_serial_list = list(corpse_dict.keys())
            corpse_serial_data = random.choice(corpse_serial_list)
            if corpse_serial == None:
              corpse_serial = corpse_serial_data

            action['action_type'] = 7
            action['item_serial'] = corpse_serial
          else:
            if hold_item_serial == 0:
              gold_item_serial, gold_item_max = \
                utils.get_serial_amount_from_corpse_item_list(corpse_item_dict, 'Gold')

              action['action_type'] = 3
              action['item_serial'] = gold_item_serial
              action['amount'] = gold_item_max
            else:
              action['action_type'] = 4

        obs = uo_service.step(action)
                </code></pre>
            </div>
        </div>

        <div class="row">
            <div class="col">
            </div>
            <div class="col">
                <h2>Conclusion</h2>
                On this page, we learned how to earn the money through hunting, which is the most basic survival strategy of MMORPG by controlling the Ultima Online client through Python code.<br>

                Of course, the corresponding motions are simple for humans, but it seems unreasonable for a Neural Network-based agent to learn from scratch in the same way as Reinforcement Learning.<br>

                Therefore, there is a need to pre-train the agent using the Supervied Learning method after saving the state and actions while the human expert is performing the corresponding process in the form of replay.<br>

                Find out how to save your play as a file on the <a href="https://kimbring2.github.io/uoservice/tutorial_replay.html">replay tutorial page</a>.

                <br>
                <br>
                <br>
                <br>
            </div>
            <div class="col">
            </div>
        </div>
    </div><!-- /.container -->
</main>

<!-- Bootstrap core JavaScript
================================================== -->
<!-- Placed at the end of the document so the pages load faster -->
<script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
<script>window.jQuery || document.write('<script src="https://getbootstrap.com/docs/4.1/assets/js/vendor/jquery-slim.min.js"><\/script>')</script>
<script src="https://getbootstrap.com/docs/4.1/assets/js/vendor/popper.min.js"></script>
<script src="https://getbootstrap.com/docs/4.1/dist/js/bootstrap.min.js"></script>
</body>
</html>