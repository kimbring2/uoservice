<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="">
    <meta name="author" content="">
    <link rel="icon" href="../../../../favicon.ico">

    <title>UoService</title>

    <!-- Bootstrap core CSS -->
    <link href="https://getbootstrap.com/docs/4.1/dist/css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom styles for this template -->
    <link href="css/tmp.css" rel="stylesheet">

    <script src="js/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </head>

  <body>
    <nav class="navbar navbar-expand-md navbar-dark bg-dark fixed-top">
      <a class="navbar-brand" href="https://github.com/kimbring2/uoservice">GitHub</a>
      <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarsExampleDefault" aria-controls="navbarsExampleDefault" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
      </button>

      <div class="collapse navbar-collapse" id="navbarsExampleDefault">
        <ul class="navbar-nav mr-auto">
            <li class="nav-item">
              <a class="nav-link" href="index.html">Home<span class="sr-only">(current)</span></a>
            </li>

            <li class="nav-item active">
              <a class="nav-link" href="states_actions.html">States/Actions<span class="sr-only"></span></a>
            </li>

            <li class="nav-item active">
              <a class="nav-link" href="tutorial_basic.html">Basic Tutorial<span class="sr-only"></span></a>
            </li>

            <li class="nav-item active">
              <a class="nav-link" href="tutorial_replay.html">Replay Tutorial<span class="sr-only"></span></a>
            </li>
        </ul>
      </div>
    </nav>
    
<main role="main" class="container-fluid">
    <div class="starter-template">
        <h1>Basic tutorial</h1>
    </div>
    <div class="container-fluid">
        <div class="row">
            <div class="col">
                <h5>Figure1: Synchronization diagram between python script and the environment.</h5>
                <img src="Fig/Process.png" class="rounded mx-auto d-block float-center" alt="Training process" width=100%>
            </div>
            <div class="col">
                <h2>Synchronization in Python</h2>
                Figure 1 shows the pattern of interaction between Python and Ultima Online client(C#) processes. First, python script 
                samples an action from the model, meanwhile the C# process waits for the action to be passed. In this 
                case <b>ActSemaphore</b> is blocked, while <b>ObsSemaphore</b> has green light. <br>
                When the <b>step</b> function is called the action tensor is sent into the shared memory and <b>ActSemaphore</b>
                turns green. It signals to C# to start processing the action of an agent. Meanwhile the <b>ObsSemaphore</b> turns
                red, blocking python process while waiting for C# to send the observation.<br>
            </div>
            <div class="col">
                <h5><a href="https://github.com/kimbring2/uoservice/blob/main/uoservice/UoService.py">Code 1: Introducing semaphores</a></h5>
                <pre class="pre"><code class="python">
class UoService:
    '''UoService class including gRPC client'''
    def __init__(self, grpc_port, window_width, window_height):
            self.grpc_port = grpc_port
            self.window_width = window_width
            self.window_height = window_height
            self.stub = None

    def _open_grpc(self):
        # Open the gRPC channel using the port that is same of game client 
        channel = grpc.insecure_channel('localhost:' + str(self.grpc_port))
        self.stub = UoService_pb2_grpc.UoServiceStub(channel)

    def step(self, action):
        # Send the action data to game client and receive the state of that action
        action_type = action['action_type']
        item_serial = action['item_serial']
        mobile_serial = action['mobile_serial']
        walk_direction = action['walk_direction']
        index = action['index']
        amount = action['amount']
        run = action['run']

        self.stub.WriteAct(UoService_pb2.GrpcAction(actionType=action_type, 
                                                    itemSerial=item_serial,
                                                    mobileSerial=mobile_serial,
                                                    walkDirection=walk_direction,
                                                    index=index, 
                                                    amount=amount,
                                                    run=run))
        self.stub.ActSemaphoreControl(UoService_pb2.SemaphoreAction(mode='post'))

        self.stub.ObsSemaphoreControl(UoService_pb2.SemaphoreAction(mode='wait'))
        response = self.stub.ReadObs(UoService_pb2.Config(name='step'))
                </code></pre>
            </div>
        </div>

        <div class="row">
            <div class="col">
            </div>
            <div class="col">
                <h2>First Walk</h2>
                The most basic action in an MMORPG game would be walking close to a specific monster. Let's see how to use the states and actions of the UoService to do that through Python code.<br> 

                The pre-work before interacting with game client is to declare the UoService class seen above, connect gRPC communication, and call the reset() function. 

                First infomation we need to know might be position of player. That can be obtained from the <b>player_game_x, player_game_y</b> of the <b>uo_service</b>. Next, we need to know information of monsters around the player, which is included in <b>world_mobile_dict</b>. There can be various types and multiple numbers of mobiles in the same space as the player. Here, only one mobile named <b>Skeleton</b> near the player is selected using the <b>name</b> and <b>distance</b> value of mobile state.

                How can we make up the arguments <b>actionType, itemSerial, mobileSerial, walkDirection, index, amount, run</b> of action for walk. First, we just know that the actionType should be 1. Next, the value for the walkDirection can be calculated from the x and y position of player and monster by using the <a href="https://github.com/kimbring2/uoservice/blob/main/uoservice/utils.py">simple planning algorithm</a>. If you need to approach quickly to monster, set the run arguemnt of action as True. 

                <video width="400" height="200" controls>
                    <source src="Fig/WalkResult.mkv" type="video/mp4">
                    Your browser does not support the video tag.
                </video>

                In the above video, the one skeleton is selected as tartget mobile and player move toward it. The full code is available from <a href="https://github.com/kimbring2/uoservice/blob/main/uoservice/examples/walk_to_monster.py">walk_to_monster.py</a> file.
            </div>

            <div class="col">
                <h5><a href="https://github.com/kimbring2/uoservice/blob/main/uoservice/examples/walk_to_monster.py">Code 2: Rule-based walking example code</a></h5>
                <pre class="pre"><code class="python">
uo_service = UoService(grpc_port, window_width, window_height)
uo_service._open_grpc()
obs = uo_service.reset()

target_serial = None

for step in tqdm(range(100000)):
    player_game_x = uo_service.player_game_x
    player_game_y = uo_service.player_game_y

    if len(uo_service.world_mobile_dict) != 0 and target_serial == None:
      serial_list = [k for k, v in uo_service.world_mobile_dict.items() \
                     v['name'] == ' A Skeleton ' and v['distance'] <= 15 \
                     and v['distance'] > 5]

      target_serial = random.choice(serial_list)

    action = {}
    action['action_type'] = 0
    action['item_serial'] = 0
    action['mobile_serial'] = 0
    action['walk_direction'] = 0
    action['index'] = 0
    action['amount'] = 0
    action['run'] = False

    if step % 50 == 0:
      if target_serial != None and player_game_x != None:
        if target_serial in uo_service.world_mobile_dict:
          target_skeleton = uo_service.world_mobile_dict[target_serial]

        target_game_x = target_skeleton["gameX"]
        target_game_y = target_skeleton["gameY"]

        direction = utils.get_walk_direction_to_target([player_game_x, player_game_y], 
                                                       [target_game_x, target_game_y])

        if direction != -1:
          action['action_type'] = 1
          action['walk_direction'] = direction
          action['run'] = True

    uo_service.step(action)
                </code></pre>
            </div>
        </div>
        
        <div class="row">
            <div class="col">
            </div>
            <div class="col">
                <h2>First Attack</h2>
                The next task the Python application can do after approaching the monster is, obviously, attack. Let's use the more states and actions of the UoService to do that. <br> 
                The first necessary information is distance between the player and monstser. If we look at the mobile data(<b>[obj.name, obj.type, obj.screenX, obj.screenY, obj.distance, obj.title]</b>) again, you can find the it easily. Player only can attack when distance is close to 0 value. <br> 
                Additionally, there is a war mode system in Ultima Online where only players in war mode can attack other players. That information can be obtained from <b>obs['player_status_dict']</b>. That data is for fundamental status of player and has the format <b>{'str': 100, 'dex': 62, 'intell': 133, 'hits': 121, 'hitsMax': 121, 'stamina': 70, 'staminaMax': 70, 'mana': 148, 'gold': 46739, 'physicalResistance': 88, 'weight': 654, 'weightMax': 450, 'HoldItemSerial': 0, 'warMode': True}</b>. The Python can use these information usefully to decide the next action. <br> 
                The <b>action_type</b> of attack action is assigned to 2 and argument need to be passed is the target mobile serial. We can use the serial what we used to find the x and y position here. As I said before, player is needed to in War Mode. Please change the mode it is not by using the <b>action['action_type'] = 19, action['index'] = 1</b> argument.

                <video width="400" height="200" controls>
                    <source src="Fig/MeleeAttackResult.mkv" type="video/mp4">
                    Your browser does not support the video tag.
                </video>

                In the demo video, player approach and attack the nearby monster randomly. The full code for that video is available from <a href="https://github.com/kimbring2/uoservice/blob/main/uoservice/examples/melee_attack_monster.py">melee_attack_monster.py</a> file.
            </div>

            <div class="col">
                <h5>Code 3: Rule-based attacking example code.</h5>
                <pre class="pre"><code class="python">
  target_mobile_serial = None

  for step in tqdm(range(100000)):
    if len(obs["mobile_data"]) != 0 and target_mobile_serial == None:
      mobile_serial_list = list(obs["mobile_data"].keys())
      target_mobile_serial = random.choice(mobile_serial_list)

    action = {}

    if step % 50 == 0:
      if target_mobile_serial != None:
        player_mobile_serial = list(obs['player_mobile_data'].keys())[0]
        player_mobile = obs['player_mobile_data'][player_mobile_serial]

        if target_mobile_serial in obs["mobile_data"]:
          target_mobile = obs["mobile_data"][target_mobile_serial]
        else:
          target_mobile_serial = None
          continue

        player_x = player_mobile[2]
        player_y = player_mobile[3]

        target_mobile_x = target_mobile[2]
        target_mobile_y = target_mobile[3]

        direction = utils.get_walk_direction_to_target([player_x, player_y], 
                                         [target_mobile_x, target_mobile_y])

        ## Distance between the player and target mobile
        distance = target_mobile[4]

        ## Format of player Status
        '''player_status_dict:  {'str': 100, 'dex': 62, 'intell': 133, 
                                 'hits': 121, 'hitsMax': 121, 'stamina': 70, 
                                 'staminaMax': 70, 'mana': 148, 'gold': 46739, 
                                 'physicalResistance': 88, 'weight': 654, 
                                 'weightMax': 450, 'HoldItemSerial': 0, 'warMode': True}'''
        war_mode = obs['player_status_dict']['warMode']

        if distance >= 2:
          if direction == -1:
            action['action_type'] = 0
          else:
            action['action_type'] = 1
            action['walk_direction'] = direction
            action['run'] = True
        else:
          ## Player is near the target
            if war_mode == False:
              ## Change the war mode to combat to attack
              action['action_type'] = 19
              action['index'] = 1
            else:
              ## Attack the target mobile
              action['action_type'] = 2
              action['mobile_serial'] = target_mobile_serial

        obs = uo_service.step(action)

                </code></pre>
            </div>

        </div>

        <div class="row">
            <div class="col">
            </div>
            <div class="col">
                <h2>Looting the corpse</h2>

                <video width="400" height="200" controls>
                    <source src="Fig/LootingCorpseResult.mkv" type="video/mp4">
                    Your browser does not support the video tag.
                </video>

                In the demo video, player approach and attack the nearby monster randomly. The full code for that video is available from <a href="https://github.com/kimbring2/uoservice/blob/main/uoservice/examples/looting_the_corpse.py">looting_the_corpse.py</a> file.
            </div>
            <div class="col">
                <h5>Code 4: Rule-based looting the corpse example code.</h5>
                <pre class="pre"><code class="python">
  target_mobile_serial = None
  corpse_serial = None

  for step in tqdm(range(100000)):
    if len(obs["mobile_data"]) != 0 and target_mobile_serial == None:
      mobile_serial_list = list(obs["mobile_data"].keys())
      target_mobile_serial = random.choice(mobile_serial_list)

    action = {}
    if step % 150 == 0:
      if len(obs['corpse_data']) != 0:
        corpse_serial_list = list(obs['corpse_data'].keys())
        corpse_serial_data = random.choice(corpse_serial_list)
        if corpse_serial == None:
          corpse_serial = corpse_serial_data
      
      if target_mobile_serial != None:
        player_mobile_serial = list(obs['player_mobile_data'].keys())[0]
        player_mobile = obs['player_mobile_data'][player_mobile_serial]

        if target_mobile_serial in obs["mobile_data"]:
          target_mobile = obs["mobile_data"][target_mobile_serial]
        else:
          target_mobile_serial = None
          continue

        player_x = player_mobile[2]
        player_y = player_mobile[3]

        target_mobile_x = target_mobile[2]
        target_mobile_y = target_mobile[3]

        direction = utils.get_walk_direction_to_target([player_x, player_y], 
                                         [target_mobile_x, target_mobile_y])

        distance = target_mobile[4]

        war_mode = obs['player_status_data']['warMode']
        hold_item_serial = obs['player_status_data']['HoldItemSerial']

        if len(obs['corpse_data']) == 0:
          if distance >= 2:
            if direction == -1:
              action['action_type'] = 0
            else:
              action['action_type'] = 1
              action['walk_direction'] = direction
              action['run'] = True
          else:
              if war_mode == False:
                action['action_type'] = 19
                action['index'] = 1
              else:
                action['action_type'] = 2
                action['mobile_serial'] = target_mobile_serial
        else:
          if len(obs['opened_corpse_data']) == 0:
            ## Open the corpse container
            corpse_serial_list = list(obs['corpse_data'].keys())
            corpse_serial_data = random.choice(corpse_serial_list)
            if corpse_serial == None:
              corpse_serial = corpse_serial_data

            action['action_type'] = 7
            action['item_serial'] = corpse_serial
          else:
            if hold_item_serial == 0:
              print("action['action_type'] = 3")

              opened_corpse_serial_list = list(obs['opened_corpse_data'].keys())
              opened_corpse_serial = random.choice(opened_corpse_serial_list)
              opened_corpse_item_list = obs['opened_corpse_data'][opened_corpse_serial]
              gold_item_serial, gold_item_max = \
                utils.get_serial_amount_from_corpse_item_list(opened_corpse_item_list, 'Gold')

              action['action_type'] = 3
              action['item_serial'] = gold_item_serial
              action['amount'] = gold_item_max
            else:
              print("action['action_type'] = 4")
              print("distance: ", distance)

              ## Item loot action
              action['action_type'] = 4

        obs = uo_service.step(action)
                </code></pre>
            </div>
        </div>

        <div class="row">
            <div class="col">
            </div>
            <div class="col">
                <h2>Conclusion</h2>
                In this tutorial we showed the first step to make your own environment in C# Engine and use it from python script.
                Right now the C# environment runs in the real time. In the next tutorial we will show how to speed it up.
                The fully functional code for this tutorial can be found here: <br><br>
                <a href="https://github.com/lupoglaz/C#GymAI/tree/master/Tutorials/InvPendulumTut">Tutorials</a><br><br>
                The C# project is located in the directory <b>InvPendulum</b> and the python Gym class is in the file <b>InvPendulum.py</b>.

                <br>
                <br>
                <br>
                <br>
            </div>
            <div class="col">
            </div>
        </div>
    </div><!-- /.container -->
</main>

<!-- Bootstrap core JavaScript
================================================== -->
<!-- Placed at the end of the document so the pages load faster -->
<script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
<script>window.jQuery || document.write('<script src="https://getbootstrap.com/docs/4.1/assets/js/vendor/jquery-slim.min.js"><\/script>')</script>
<script src="https://getbootstrap.com/docs/4.1/assets/js/vendor/popper.min.js"></script>
<script src="https://getbootstrap.com/docs/4.1/dist/js/bootstrap.min.js"></script>
</body>
</html>