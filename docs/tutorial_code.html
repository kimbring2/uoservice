<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="">
    <meta name="author" content="">
    <link rel="icon" href="../../../../favicon.ico">

    <title>UoService</title>

    <!-- Bootstrap core CSS -->
    <link href="https://getbootstrap.com/docs/4.1/dist/css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom styles for this template -->
    <link href="css/tmp.css" rel="stylesheet">

    <script src="js/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    <style>
        body {
            padding-top: 5rem;
            padding: 20px 6%;
        }
        
        #toc_container {
            background: #f9f9f9 none repeat scroll 0 0;
            border: 1px solid #aaa;
            display: table;
            font-size: 95%;
            margin-bottom: 1em;
            padding: 20px;
            width: auto;
        }

        .toc_title {
            font-weight: 700;
            text-align: center;
            font-size: 150%;
        }

        .toc_list {
            font-weight: 1500;
            font-size: 120%;
        }

        #toc_container li, #toc_container ul, #toc_container ul li{
            list-style: outside none none !important;
        }

        .gototop{
          position: fixed;
          display: block;
          box-sizing: border-box;
          height: 50px;
          width: 50px;
          border: none;
          background-color: #FD3437;
          border-radius: 3px;
          bottom: 50px;
          right: 50px;
          margin-right: -30px;
          outline: none;
          opacity: 0;
          transition: opacity .3s ease, margin-right .5s ease-out;
        }

        .visible{
          transition: opacity .3s ease, margin-right .5s ease-out;
          margin-right: 0px;
          opacity: .6;
        }

        .gototop::before, .gototop::after{
          content: '';
          position: absolute;
          height: 18px;
          width: 2px;
          background-color: #fff;
          top: 16px;
        }

        .gototop::before{
          left: 18px;
          transform: rotate(45deg);
        }

        .gototop::after{
          right: 18px;
          transform: rotate(-45deg);
        }

        .python {
          width: 600px;
          overflow-x: scroll;
        }
    </style>
  </head>

  <body-code>
    <button class="gototop"></button>
    
    <nav class="navbar navbar-expand-md navbar-dark bg-dark fixed-top">
      <a class="navbar-brand" href="https://github.com/kimbring2/uoservice">GitHub</a>
      <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarsExampleDefault" aria-controls="navbarsExampleDefault" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
      </button>

      <div class="collapse navbar-collapse" id="navbarsExampleDefault">
        <ul class="navbar-nav mr-auto">
            <li class="nav-item">
              <a class="nav-link" href="index.html">Home<span class="sr-only">(current)</span></a>
            </li>

            <li class="nav-item active">
              <a class="nav-link" href="tutorial_grpc.html">gRPC Tutorial<span class="sr-only"></span></a>
            </li>

            <li class="nav-item active">
              <a class="nav-link" href="tutorial_binary_file.html">Binary File Tutorial<span class="sr-only"></span></a>
            </li>

            <li class="nav-item active">
              <a class="nav-link" href="tutorial_code.html">Code Tutorial<span class="sr-only"></span></a>
            </li>

            <li class="nav-item active">
              <a class="nav-link" href="tutorial_replay.html">Replay Tutorial<span class="sr-only"></span></a>
            </li>

            <li class="nav-item active">
              <a class="nav-link" href="https://discord.gg/zMBubyVE">Discord<span class="sr-only"></span></a>
            </li>
        </ul>
      </div>
    </nav>
    
<main role="main" class="container-fluid">
    <div class="starter-template">
        <h1>Code Tutorial</h1>
    </div>

    <div class="row">
        <div class="col">
        </div>

        <div class="col" id="toc_container">
            <div class="col">
            </div>
            <p class="toc_title">Contents</p>
            <ul class="toc_list">
                <li><a href="#uoservice_class">1. UoService Class</a></li>
                <li><a href="#land_static_data">2. Land, Static Data</a></li>
                <li><a href="#first_walk">3. First Walk</a></li>
                <li><a href="#first_attack">4. First Attack</a></li>
                <li><a href="#first_looting">5. First Looting</a></li>
                <li><a href="#first_mining">6. First Mining</a></li>
                <li><a href="#first_smelting">7. First Smelting</a></li>
                <li><a href="#conclusion">8. Conclusion</a></li>
            </ul>
        </div>

        <div class="col">
        </div>
    </div>

    <hr>

    <div class="container-fluid">
        <div class="row" id="uoservice_class">
            <div class="col">
                <h5>Figure1: Synchronization diagram between python script and the environment.</h5>
                <img src="Fig/Process.png" class="rounded mx-auto d-block float-center" alt="Training process" width=100%>
            </div>
            <div class="col">
                <h2>1. UoService Class</h2>
                Figure 1 shows the pattern of interaction between Python and Ultima Online client(C#) processes. First, python script 
                samples an action from the model, meanwhile the C# process waits for the action to be passed. In this 
                case <b>ActSemaphore</b> is blocked, while <b>ObsSemaphore</b> has green light. <br>
                When the <b>step</b> function is called the action tensor is sent into the shared memory and <b>ActSemaphore</b>
                turns green. It signals to C# to start processing the action of an agent. Meanwhile the <b>ObsSemaphore</b> turns
                red, blocking python process while waiting for C# to send the observation.<br>
            </div>
            <div class="col">
                <h5><a href="https://github.com/kimbring2/uoservice/blob/main/uoservice/UoService.py">Code 1: UoService Class</a></h5>
                <pre class="pre"><code class="python">
class UoService:
    '''UoService class including gRPC client'''
    def __init__(self, grpc_port, window_width, window_height):
        self.grpc_port = grpc_port
        self.window_width = window_width
        self.window_height = window_height
        self.stub = None

        self.uo_installed_path = "/home/kimbring2/.wine/drive_c/Program Files (x86)/Electronic Arts/Ultima Online Classic"
        self.uoservice_game_file_parser = UoServiceGameFileParser(self.uo_installed_path)

    def _open_grpc(self):
        # Open the gRPC channel using the port that is same of game client 
        channel = grpc.insecure_channel('localhost:' + str(self.grpc_port))
        self.stub = UoService_pb2_grpc.UoServiceStub(channel)

    def parse_land_static(self):
        while True:
            if self.max_tile_x != None:
                cell_x_list = []
                cell_y_list = []
                tile_data_list = []

                for x in range(self.min_tile_x, self.max_tile_x):
                    cell_x = x >> 3
                    if cell_x not in cell_x_list:
                        cell_x_list.append(cell_x)

                for y in range(self.min_tile_y, self.max_tile_y):
                    cell_y = y >> 3
                    if cell_y not in cell_y_list:
                        cell_y_list.append(cell_y)

                cell_zip = zip(cell_x_list, cell_y_list)
                for cell_x in cell_x_list:
                    for cell_y in cell_y_list:
                        tile_data = self.uoservice_game_file_parser.get_tile_data(cell_x, cell_y)

                        for tile in tile_data:
                            if tile["name"] == "forest":
                        
                        tile_data_list.append(tile_data)

    def step(self, action):
        # Send the action data to game client and receive the state of that action
        action_type = action['action_type']
        source_serial = action['source_serial']
        target_serial = action['target_serial']
        walk_direction = action['walk_direction']
        index = action['index']
        amount = action['amount']
        run = action['run']

        self.stub.WriteAct(UoService_pb2.GrpcAction(actionType=action_type, 
                                                    sourceSerial=source_serial,
                                                    targetSerial=target_serial,
                                                    walkDirection=walk_direction,
                                                    index=index, 
                                                    amount=amount,
                                                    run=run))
        self.stub.ActSemaphoreControl(UoService_pb2.SemaphoreAction(mode='post'))

        self.stub.ObsSemaphoreControl(UoService_pb2.SemaphoreAction(mode='wait'))
        response = self.stub.ReadObs(UoService_pb2.Config(name='step'))
                </code></pre>
            </div>
        </div>

        <div class="row" id="land_static_data">
            <div class="col">
                <h5>Figure2: State Transmission Paths.</h5>
                <img src="Fig/ThreadDiagram.png" class="rounded mx-auto d-block float-center" alt="Training process" width=100%>
            </div>
            <div class="col">
                <h2>2. Land and Static Data</h2>
                In the case of Land and Static objects, there are far more numbers on one screen than Mobile and Item objects. If all objects are received through one loop, there will be significant delay.

                Fortunately, Land and Static are read from a binary file unlike Mobile and Item data acquired through gRPC. Therefore we can use the two threads to perform both tasks simultaneously as can be seen in Figure 2. 

                In the case of Land and Static objects, there will not be a serious problem even if the incoming order are slightly changed with the Mobile and Item object information because the information will never change unless the agent moves.
            </div>
            <div class="col">
                <h5><a href="https://github.com/kimbring2/uoservice/blob/main/uoservice/UoService.py">Code 2: Land and Static Data</a></h5>
                <pre class="pre"><code class="python">
import threading
from uoservice.protos import UoService_pb2
from uoservice.protos import UoService_pb2_grpc
from uoservice.UoService import UoService
from uoservice.UoServiceGameFileParser import UoServiceGameFileParser

def parse_land_static(uo_service):
  while True:
    if uo_service.max_tile_x != None:
      cell_x_list = []
      cell_y_list = []
      for x in range(uo_service.min_tile_x, uo_service.max_tile_x):
        cell_x = x >> 3
        if cell_x not in cell_x_list:
          cell_x_list.append(cell_x)

      for y in range(uo_service.min_tile_y, uo_service.max_tile_y):
        cell_y = y >> 3
        if cell_y not in cell_y_list:
          cell_y_list.append(cell_y)

      cell_zip = zip(cell_x_list, cell_y_list)
      for cell_x in cell_x_list:
        for cell_y in cell_y_list:
          tile_data = uo_service.uoservice_game_file_parser.get_tile_data(cell_x, cell_y)

          for tile in tile_data:
            if tile["name"] == "forest":
              print("name: {0}, game_x: {1}, game_y: {2}".format(tile["name"], tile["game_x"], tile["game_y"]))
          

def step(uo_service):
  action_flag = True

  while True:
    ## Declare the empty action
    action = {}
    action['action_type'] = 0
    action['source_serial'] = 0
    action['target_serial'] = 0
    action['walk_direction'] = 0
    action['index'] = 0
    action['amount'] = 0
    action['run'] = False

    backpack_item_data = uo_service.backpack_item_dict
    equipped_item_data = uo_service.equipped_item_dict
    player_status_dict = uo_service.player_status_dict

    if step % 150 == 0:
      ## Excecute the speciec action
      if action_flag == True:
        action['action_type'] = 0
        action['target_serial'] = gold_serial
        action['amount'] = 100
        action_flag = False

    obs = uo_service.step(action)

## Declare the main function
def main():
  ## Declare the UoService using the parsed argument
  uo_service = UoService(grpc_port, window_width, window_height)

  ## Open the gRPC client to connect with gRPC server of CSharp part
  uo_service._open_grpc()

  ## Send the reset signal to gRPC server
  obs = uo_service.reset()

  thread_2 = threading.Thread(target=step, daemon=True, args=(uo_service,))
  thread_1 = threading.Thread(target=parse_land_static, daemon=True, args=(uo_service,))

  thread_2.start()
  thread_1.start()

  thread_2.join()
  thread_1.join()
                </code></pre>
            </div>
        </div>

        <div class="row" id="first_walk">
            <div class="col">
            </div>
            <div class="col">
                <h2>3. First Walk</h2>
                The most basic action in an MMORPG game would be walking close to a specific monster. Let's see how to use the states and actions of the UoService to do that through Python code.<br> 

                The pre-work before interacting with game client is to declare the UoService class seen above, connect gRPC communication, and call the reset() function. 

                First infomation we need to know might be position of player. That can be obtained from the <b>player_game_x, player_game_y</b> of the <b>uo_service</b>. Next, we need to know information of monsters around the player, which is included in <b>world_mobile_dict</b>. There can be various types and multiple numbers of mobiles in the same space as the player. Here, only one mobile named <b>Skeleton</b> near the player is selected using the <b>name</b> and <b>distance</b> value of mobile state.

                How can we make up the arguments <b>actionType, sourceSerial, targetSerial, walkDirection, index, amount, run</b> of action for walk. First, we just know that the actionType should be 1. Next, the value for the walkDirection can be calculated from the x and y position of player and monster by using the <a href="https://github.com/kimbring2/uoservice/blob/main/uoservice/utils.py">simple planning algorithm</a>. If you need to approach quickly to monster, set the run arguemnt of action as True. 

                <video width="400" height="200" controls>
                    <source src="Fig/WalkResult.mkv" type="video/mp4">
                    Your browser does not support the video tag.
                </video>
            </div>

            <div class="col">
                <h5><a href="https://github.com/kimbring2/uoservice/blob/main/uoservice/examples/walk_to_monster.py">Code 3: Rule-based walking example code</a></h5>
                <pre class="pre"><code class="python">
uo_service = UoService(grpc_port, window_width, window_height)
uo_service._open_grpc()
obs = uo_service.reset()

target_serial = None

for step in range(100000):
    player_game_x = uo_service.player_game_x
    player_game_y = uo_service.player_game_y

    if len(uo_service.world_mobile_dict) != 0 and target_serial == None:
      serial_list = [k for k, v in uo_service.world_mobile_dict.items() \
                     v['name'] == ' A Skeleton ' and v['distance'] <= 10 \
                     and v['distance'] > 1]

      target_serial = random.choice(serial_list)

    action = {}
    action['action_type'] = 0
    action['source_serial'] = 0
    action['target_serial'] = 0
    action['walk_direction'] = 0
    action['index'] = 0
    action['amount'] = 0
    action['run'] = False

    if step % 50 == 0:
      if target_serial != None and player_game_x != None:
        if target_serial in uo_service.world_mobile_dict:
          target_skeleton = uo_service.world_mobile_dict[target_serial]

        target_game_x = target_skeleton["gameX"]
        target_game_y = target_skeleton["gameY"]

        direction = utils.get_walk_direction_to_target([player_game_x, player_game_y], 
                                                       [target_game_x, target_game_y])

        if direction != -1:
          action['action_type'] = 1
          action['walk_direction'] = direction
          action['run'] = True

    uo_service.step(action)
                </code></pre>
            </div>
        </div>
        
        <div class="row" id="first_attack">
            <div class="col">
            </div>
            <div class="col">
                <h2>4. First Attack</h2>
                After getting close to a monster, the most basic interaction possible would be an attack. Let's use the more state and action of the UoService to do that. <br> 
                Melee attacks are possible only when the distance from the monster is almost zero. Therefore, this distance should be checked before attacking. This information is contained in the mobile's <b>distance</b> part, and you can acquire a value through the <b>target_mobile['distance']</b> code.<br> 
                
                Next, the player must be in the war mode to attack enemie in Ultima Online. You must check the current status of mode by using the <b>war_mode</b> value of UoService class like a <b>uo_service.war_mode</b> If it is false, set the <b>action_type</b> and <b>index</b> argument of action to 19 and 1 respectively to set the player as war mode. <br> 

                Finally, if the player approach close to the monster and war mode is true, you can set the <b>action_type</b> as 2. Additionally, the <b>target_serial</b> argument is needed to be set as the serial of target mobile.

                <video width="400" height="200" controls>
                    <source src="Fig/MeleeAttackResult.mkv" type="video/mp4">
                    Your browser does not support the video tag.
                </video>
            </div>

            <div class="col">
                <h5><a href="https://github.com/kimbring2/uoservice/blob/main/uoservice/examples/melee_attack_monster.py">Code 4: Rule-based attacking example code</a>.</h5>
                <pre class="pre"><code class="python">
uo_service = UoService(grpc_port, window_width, window_height)
uo_service._open_grpc()
obs = uo_service.reset()

target_serial = None
for step in range(100000):
    player_game_x = uo_service.player_game_x
    player_game_y = uo_service.player_game_y
    if len(uo_service.world_mobile_dict) != 0 and target_serial == None:
      mobile_serial_list = [k for k, v in uo_service.world_mobile_dict.items() \
                     v['name'] == ' A Skeleton ' and v['distance'] <= 10 \
                     and v['distance'] > 1]
      target_serial = random.choice(mobile_serial_list)

    action = {}
    action['action_type'] = 0
    action['source_serial'] = 0
    action['target_serial'] = 0
    action['walk_direction'] = 0
    action['index'] = 0
    action['amount'] = 0
    action['run'] = False

    if step % 50 == 0:
      if target_serial != None and player_game_x != None:
        if target_serial in uo_service.world_mobile_dict:
          target_mobile = uo_service.world_mobile_dict[target_serial]

        target_game_x = target_mobile["gameX"]
        target_game_y = target_mobile["gameY"]

        direction = utils.get_walk_direction_to_target([player_game_x, player_game_y], 
                                                       [target_game_x, target_game_y])
        distance = target_mobile['distance']
        war_mode = uo_service.war_mode

        if distance >= 2:
          if direction == -1:
            action['action_type'] = 0
          else:
            ## Walk toward target mobile
            action['action_type'] = 1
            action['walk_direction'] = direction
            action['run'] = True
        else:
            if war_mode == False:
              action['action_type'] = 19
              action['index'] = 1
            else:
              action['action_type'] = 2
              action['target_serial'] = target_serial
        
        obs = uo_service.step(action)
                </code></pre>
            </div>
        </div>

        <div class="row" id="first_looting">
            <div class="col">
            </div>
            <div class="col">
                <h2>5. First looting</h2>
                After attacking and killing a monster, player can acquire various items including gold from the corpse. To do this with python code, first you need to check <b>world_item_dict</b> of the <b>uo_service</b> instead of the <b>world_mobile_dict</b> because the monster that was mobile type is transformed to an item when it dies. For the reason that the corresponding Dict has information on all items of the world, you should filter it using the <b>isCorpse</b> value.<br>

                Having secured the serial number of the corpse that exists around the player, the next step is to open it. The corresponding action can be composed by setting the <b>action_type</b> as 7 and <b>target_serial</b> as the serial number of the corpse item.<br>

                From the moment the corpse is opened, world_item_dict start to include the items of that corpse. To determine which item is inside the corpse, the <b>container</b> part of item information can be used <b>item["container"]</b>. If you want to select only gold among the identified items inside the corpse, you can use the <b>name</b> information of item like a <b>if "gold" in item["name"]</b>.<br>

                Having obtained a serial of the gold item of opened corpse, that item should be picked up before putting it in the player backpack. This can be done by setting the <b>action_type</b> as 3, <b>target_serial</b> to the serial of the gold item, and <b>amount</b> to the total number of gold.<br>

                When picking up an item, <b>hold_item_serial</b> of <b>uo_service</b> is changed to the serial number of the item. Finally, player can drop the currently held item onto the backpack by setting <b>action_type</b> to 4 causes the.<br>

                In order to check whether the player looted gold well, you can check the <b>gold part</b> of <b>player_status_dict</b> of the <b>uo_service</b> like <b>player_status_dict['gold']</b>.

                <video width="400" height="200" controls>
                    <source src="Fig/LootingCorpseResult.mkv" type="video/mp4">
                    Your browser does not support the video tag.
                </video>
            </div>
            <div class="col">
                <h5><a href="https://github.com/kimbring2/uoservice/blob/main/uoservice/examples/looting_the_corpse.py">Code 5: Rule-based looting example code</a>.</h5>
                <pre class="pre"><code class="python">
  target_mobile_serial = None
  corpse_dict = {}
  corpse_serial = None
  hold_item_serial = 0
  corpse_item_dict = {}

  for step in range(100000):
    player_game_x = uo_service.player_game_x
    player_game_y = uo_service.player_game_y

    if len(uo_service.world_mobile_dict) != 0 and target_mobile_serial == None:
      skeleton_serial_list = [k for k, v in uo_service.world_mobile_dict.items() \
               if v['name'] == ' A Skeleton ' and v['distance'] <= 10 and v['distance'] > 1]
      target_mobile_serial = random.choice(skeleton_serial_list)

    corpse_dict = {}
    for k, v in uo_service.world_item_dict.items():
      if v["isCorpse"] == True:
        corpse_dict[k] = v

    action = {}
    action['action_type'] = 0
    action['source_serial'] = 0
    action['target_serial'] = 0
    action['walk_direction'] = 0
    action['index'] = 0
    action['amount'] = 0
    action['run'] = False

    if step % 150 == 0:
      if len(uo_service.player_status_dict) != 0:
        player_gold = uo_service.player_status_dict['gold']

      if target_mobile_serial != None and player_game_x != None:
        if target_mobile_serial in uo_service.world_mobile_dict:
          target_mobile = uo_service.world_mobile_dict[target_skeleton_serial]
        else:
          target_mobile_serial = None
          continue

        target_mobile_game_x = target_mobile["gameX"]
        target_mobile_game_y = target_mobile["gameY"]

        direction = utils.get_walk_direction_to_target([player_game_x, player_game_y], 
                                         [target_mobile_game_x, target_mobile_game_y])
        distance = target_mobile['distance']
        war_mode = uo_service.war_mode
        hold_item_serial = uo_service.hold_item_serial

        for k_corpse, v_corpse in corpse_dict.items():
          for k_world, v_world in uo_service.world_item_dict.items():
            if k_corpse == v_world["container"]:
              if k_world not in corpse_item_dict:
                corpse_item_dict[k_world] = uo_service.world_item_dict[k_world]
              else:
                corpse_item_dict[k_world] = uo_service.world_item_dict[k_world]

        if len(corpse_dict) == 0:
          if distance >= 2:
            if direction == -1:
              action['action_type'] = 0
            else:
              action['action_type'] = 1
              action['walk_direction'] = direction
              action['run'] = True
          else:
              if war_mode == False:
                action['action_type'] = 19
                action['index'] = 1
              else:
                action['action_type'] = 2
                action['target_serial'] = target_mobile_serial
        else:
          if len(corpse_item_dict) == 0:
            corpse_serial_list = list(corpse_dict.keys())
            corpse_serial_data = random.choice(corpse_serial_list)
            if corpse_serial == None:
              corpse_serial = corpse_serial_data

            action['action_type'] = 7
            action['target_serial'] = corpse_serial
          else:
            if hold_item_serial == 0:
              gold_item_serial, gold_item_max = \
                utils.get_serial_amount_from_corpse_item_list(corpse_item_dict, 'Gold')

              action['action_type'] = 3
              action['target_serial'] = gold_item_serial
              action['amount'] = gold_item_max
            else:
              action['action_type'] = 4
              action['target_serial'] = backpack_serial

        obs = uo_service.step(action)
                </code></pre>
            </div>
        </div>

        <div class="row" id="first_mining">
            <div class="col">
                <h2>6. First mining</h2>
                In Ultima Online, player is able to obtain various ingridents to craft the items through the gathering from nature. For example, iron ores must be gathered from nearby mines in order to craft items such as sword. To collect ore, you must equip a PickAxe in one hand tha can be chekced using the <b>equipped_item_dict["OneHanded"]</b> information of <b>UoService</b>. If you are holding a Pickaxe in one hand instead of something else, you need to unequip it first. This can be done by setting the action's <b>action_type</b> to 3 and <b>target_serial</b> to the serial of the currently held item. Next, set the <b>action_type</b> of the action to 4 and the <b>target_serial</b> to the backpack's serial, and put the held item into the backpack. Next, pick up the PickAxe of the backpack in the same way, and set the <b>action_type</b> to 6 to equip it.

                After that, if you double-click the pickaxe item, you can use the unique ability of the item for the position target. In this case, it is mining skill becauise item is Pickaxe. The <b>uo_service.targeting_state</b> value is changed from -1 to 1 when the tarining status is set as ground target.

                When a human plays the game, the target land can be selected by mouse-clicking. How to deliver that kind of action in <b>UoService</b> that has an x and y. 

                <br>
                <br>

                <a href="https://kimbring2.github.io/uoservice/tutorial_binary_file.html#land_indexing">land indexing</a>

                <h5>Figure3: Diagram of Land target indexing.</h5>
                <img src="Fig/MineTileIndex.png" class="rounded mx-auto d-block float-center" alt="Training process" width=100%>
            </div>
            <div class="col">
                <h5><a href="https://github.com/kimbring2/uoservice/blob/main/uoservice/examples/mine_ore.py">Code 6: Rule-based mining example code</a>.</h5>
                <pre class="pre"><code class="python">
def step(uo_service):
  pickaxe_serial = None
  equip_item_flag = False
  unequip_item_serial = None
  pickaxe_item_serial = None
  onehanded_item_serial = None
  drop_item_serial = None
  picked_up_item_serial = None

  mining_prepare_flag = False
  mining_ready_flag = False

  targeting_type = None

  one_time_trial = True
  while True:
    backpack_item_data = uo_service.backpack_item_dict
    equipped_item_dict = uo_service.equipped_item_dict
    hold_item_serial = uo_service.hold_item_serial
    targeting_state = uo_service.targeting_state

    unequip_item_serial = None
    pickaxe_item_serial = None
    if "OneHanded" in equipped_item_dict:
      if equipped_item_dict["OneHanded"]["name"] != "Pickaxe":
        unequip_item_serial = equipped_item_dict["OneHanded"]["serial"]
      elif equipped_item_dict["OneHanded"]["name"] == "Pickaxe":
        onehanded_item_serial = equipped_item_dict["OneHanded"]["serial"]
        if mining_ready_flag == False:
          mining_prepare_flag = True
    else:
      for k_backpack, v_backpack in backpack_item_data.items():
        if v_backpack["name"] == "Pickaxe":
          pickaxe_item_serial = k_backpack

    player_status_dict = uo_service.player_status_dict

    pickaxe_serial, index = utils.get_serial_by_name(backpack_item_data, 'Gold')

    if pickaxe_serial in backpack_item_data:
      pickaxe_serial = backpack_item_data[pickaxe_serial]
    else:
      print("pickaxe_serial is not in backpack_item_data")

    if step % 100 == 0:
      if unequip_item_serial != None:
        print("Pick up the equipped item from player")

        action['action_type'] = 3
        action['target_serial'] = unequip_item_serial

        unequip_item = uo_service.world_item_dict[unequip_item_serial]
        uo_service.picked_up_item = unequip_item

        drop_item_serial = unequip_item_serial
        unequip_item_serial = None
      elif drop_item_serial != None and uo_service.backpack_serial: 
        print("Drop the holded item into backpack")

        action['action_type'] = 4
        action['target_serial'] = uo_service.backpack_serial
        drop_item_serial = None
      elif pickaxe_item_serial != None:
        print("Pick up the Pickaxe item from backpack")

        action['action_type'] = 3
        action['target_serial'] = pickaxe_item_serial
        equip_item_flag = True
      elif equip_item_flag == True:
        print("Equip the holded item")

        action['action_type'] = 6
        equip_item_flag = False
      elif mining_prepare_flag == True and one_time_trial == True:
        print("Double click the Pickaxe item")

        action['action_type'] = 2
        action['target_serial'] = onehanded_item_serial

        mining_prepare_flag = False
        mining_ready_flag = True
        one_time_trial = False
      elif mining_ready_flag == True and targeting_state == 1:
        print("Mining the land target")

        action['action_type'] = 5
        action['index'] = 2554
        mining_ready_flag = False

    obs = uo_service.step(action)
                </code></pre>
            </div>
        </div>

        <div class="row" id="first_smelting">
            <div class="col">
            </div>
            <div class="col">
                <h2>7. First Smelting</h2>
            </div>
            <div class="col">
                <h5><a href="https://github.com/kimbring2/uoservice/blob/main/uoservice/examples/make_ingot.py">Code 7: Rule-based smelting example code</a>.</h5>
                <pre class="pre"><code class="python">
def step(uo_service):
  pickaxe_serial = None
  equip_item_flag = False
  unequip_item_serial = None
  pickaxe_item_serial = None
  onehanded_item_serial = None
  drop_item_serial = None
  picked_up_item_serial = None

  mining_prepare_flag = False
  mining_ready_flag = False

  targeting_type = None

  one_time_trial = True
  while True:
    backpack_item_data = uo_service.backpack_item_dict
    equipped_item_dict = uo_service.equipped_item_dict
    hold_item_serial = uo_service.hold_item_serial
    targeting_state = uo_service.targeting_state

    unequip_item_serial = None
    pickaxe_item_serial = None
    if "OneHanded" in equipped_item_dict:
      if equipped_item_dict["OneHanded"]["name"] != "Pickaxe":
        unequip_item_serial = equipped_item_dict["OneHanded"]["serial"]
      elif equipped_item_dict["OneHanded"]["name"] == "Pickaxe":
        onehanded_item_serial = equipped_item_dict["OneHanded"]["serial"]
        if mining_ready_flag == False:
          mining_prepare_flag = True
    else:
      for k_backpack, v_backpack in backpack_item_data.items():
        if v_backpack["name"] == "Pickaxe":
          pickaxe_item_serial = k_backpack

    player_status_dict = uo_service.player_status_dict

    pickaxe_serial, index = utils.get_serial_by_name(backpack_item_data, 'Gold')

    if pickaxe_serial in backpack_item_data:
      pickaxe_serial = backpack_item_data[pickaxe_serial]
    else:
      print("pickaxe_serial is not in backpack_item_data")

    if step % 100 == 0:
      if unequip_item_serial != None:
        print("Pick up the equipped item from player")

        action['action_type'] = 3
        action['target_serial'] = unequip_item_serial

        unequip_item = uo_service.world_item_dict[unequip_item_serial]
        uo_service.picked_up_item = unequip_item

        drop_item_serial = unequip_item_serial
        unequip_item_serial = None
      elif drop_item_serial != None and uo_service.backpack_serial: 
        print("Drop the holded item into backpack")

        action['action_type'] = 4
        action['target_serial'] = uo_service.backpack_serial
        drop_item_serial = None
      elif pickaxe_item_serial != None:
        print("Pick up the Pickaxe item from backpack")
        action['action_type'] = 3
        action['target_serial'] = pickaxe_item_serial
        equip_item_flag = True
      elif equip_item_flag == True:
        print("Equip the holded item")
        action['action_type'] = 6
        equip_item_flag = False
      elif mining_prepare_flag == True and one_time_trial == True:
        print("Double click the Pickaxe item")
        action['action_type'] = 2
        action['target_serial'] = onehanded_item_serial

        mining_prepare_flag = False
        mining_ready_flag = True
        one_time_trial = False
      elif mining_ready_flag == True and targeting_state == 1:
        print("Mining the land target")
        action['action_type'] = 5
        action['index'] = 2554
        mining_ready_flag = False

    obs = uo_service.step(action)

    step += 1
                </code></pre>
            </div>
        </div>

        <div class="row" id="conclusion">
            <div class="col">
            </div>
            <div class="col">
                <h2>Conclusion</h2>
                On this page, we learned how to earn the money through hunting, which is the most basic survival strategy of MMORPG by controlling the Ultima Online client through Python code.<br>

                Of course, the corresponding motions are simple for humans, but it seems unreasonable for a Neural Network-based agent to learn from scratch in the same way as Reinforcement Learning.<br>

                Therefore, there is a need to pre-train the agent using the Supervied Learning method after saving the state and actions while the human expert is performing the corresponding process in the form of replay.<br>

                Find out how to save your play as a file on the <a href="https://kimbring2.github.io/uoservice/tutorial_replay.html">replay tutorial page</a>.

                <br>
                <br>
                <br>
                <br>
            </div>
            <div class="col">
            </div>
        </div>
    </div><!-- /.container -->
</main>

<!-- Bootstrap core JavaScript
================================================== -->
<!-- Placed at the end of the document so the pages load faster -->
<script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
<script>window.jQuery || document.write('<script src="https://getbootstrap.com/docs/4.1/assets/js/vendor/jquery-slim.min.js"><\/script>')</script>
<script src="https://getbootstrap.com/docs/4.1/assets/js/vendor/popper.min.js"></script>
<script src="https://getbootstrap.com/docs/4.1/dist/js/bootstrap.min.js"></script>

<script src="js/function.js"></script>

</body-code>
</html>